package com.alex;

import com.alex.scanner.Scanner;
import com.alex.scanner.Token;
import com.alex.scanner.TokenType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class ScannerTest {
    record Case<T, U>(T in, U expected) { }
    public static final Token EOF_TOK = new Token(TokenType.EOF, "", null, 1);

    @ParameterizedTest
    @MethodSource("simpleScanTests")
    void testScanTokens_simpleCases(Case<String, List<Token>> tc) {
        var scanner = new Scanner(tc.in);
        var r = scanner.scanTokens();

        assertIterableEquals(tc.expected, r.tokens());
        assertTrue(r.errors().isEmpty());
    }

    @Test
    void scanTokens_unterminatedString_literalError() {
        var scanner = new Scanner("\"unterminated");
        var result = scanner.scanTokens();

        assertEquals(List.of(EOF_TOK), result.tokens());
        assertEquals(1, result.errors().size());
    }

    // Tests generated by Copilot :)
    static List<Case<String, List<Token>>> simpleScanTests() {
        return List.of(
                // Single-character tokens
                new Case<>("(", List.of(new Token(TokenType.LEFT_PAREN, "(", null, 1), EOF_TOK)),
                new Case<>(")", List.of(new Token(TokenType.RIGHT_PAREN, ")", null, 1), EOF_TOK)),
                new Case<>("{", List.of(new Token(TokenType.LEFT_BRACE, "{", null, 1), EOF_TOK)),
                new Case<>("}", List.of(new Token(TokenType.RIGHT_BRACE, "}", null, 1), EOF_TOK)),
                new Case<>(",", List.of(new Token(TokenType.COMMA, ",", null, 1), EOF_TOK)),
                new Case<>(".", List.of(new Token(TokenType.DOT, ".", null, 1), EOF_TOK)),
                new Case<>("-", List.of(new Token(TokenType.MINUS, "-", null, 1), EOF_TOK)),
                new Case<>("+", List.of(new Token(TokenType.PLUS, "+", null, 1), EOF_TOK)),
                new Case<>(";", List.of(new Token(TokenType.SEMICOLON, ";", null, 1), EOF_TOK)),
                new Case<>("/", List.of(new Token(TokenType.SLASH, "/", null, 1), EOF_TOK)),
                new Case<>("*", List.of(new Token(TokenType.STAR, "*", null, 1), EOF_TOK)),

                // Multi-character tokens
                new Case<>("!", List.of(new Token(TokenType.BANG, "!", null, 1), EOF_TOK)),
                new Case<>("!=", List.of(new Token(TokenType.BANG_EQUAL, "!=", null, 1), EOF_TOK)),
                new Case<>("=", List.of(new Token(TokenType.EQUAL, "=", null, 1), EOF_TOK)),
                new Case<>("==", List.of(new Token(TokenType.EQUAL_EQUAL, "==", null, 1), EOF_TOK)),
                new Case<>(">", List.of(new Token(TokenType.GREATER, ">", null, 1), EOF_TOK)),
                new Case<>(">=", List.of(new Token(TokenType.GREATER_EQUAL, ">=", null, 1), EOF_TOK)),
                new Case<>("<", List.of(new Token(TokenType.LESS, "<", null, 1), EOF_TOK)),
                new Case<>("<=", List.of(new Token(TokenType.LESS_EQUAL, "<=", null, 1), EOF_TOK)),

                // Identifiers
                new Case<>("identifier", List.of(new Token(TokenType.IDENTIFIER, "identifier", null, 1), EOF_TOK)),

                // String literals
                new Case<>("\"hello\"", List.of(new Token(TokenType.STRING, "\"hello\"", "hello", 1), EOF_TOK)),

                // Number literals
                new Case<>("123", List.of(new Token(TokenType.NUMBER, "123", 123.0, 1), EOF_TOK)),
                new Case<>("123.45", List.of(new Token(TokenType.NUMBER, "123.45", 123.45, 1), EOF_TOK)),

                // Keywords
                new Case<>("and", List.of(new Token(TokenType.AND, "and", null, 1), EOF_TOK)),
                new Case<>("class", List.of(new Token(TokenType.CLASS, "class", null, 1), EOF_TOK)),
                new Case<>("else", List.of(new Token(TokenType.ELSE, "else", null, 1), EOF_TOK)),
                new Case<>("false", List.of(new Token(TokenType.FALSE, "false", null, 1), EOF_TOK)),
                new Case<>("fun", List.of(new Token(TokenType.FUN, "fun", null, 1), EOF_TOK)),
                new Case<>("for", List.of(new Token(TokenType.FOR, "for", null, 1), EOF_TOK)),
                new Case<>("if", List.of(new Token(TokenType.IF, "if", null, 1), EOF_TOK)),
                new Case<>("nil", List.of(new Token(TokenType.NIL, "nil", null, 1), EOF_TOK)),
                new Case<>("or", List.of(new Token(TokenType.OR, "or", null, 1), EOF_TOK)),
                new Case<>("print", List.of(new Token(TokenType.PRINT, "print", null, 1), EOF_TOK)),
                new Case<>("return", List.of(new Token(TokenType.RETURN, "return", null, 1), EOF_TOK)),
                new Case<>("super", List.of(new Token(TokenType.SUPER, "super", null, 1), EOF_TOK)),
                new Case<>("this", List.of(new Token(TokenType.THIS, "this", null, 1), EOF_TOK)),
                new Case<>("true", List.of(new Token(TokenType.TRUE, "true", null, 1), EOF_TOK)),
                new Case<>("var", List.of(new Token(TokenType.VAR, "var", null, 1), EOF_TOK)),
                new Case<>("while", List.of(new Token(TokenType.WHILE, "while", null, 1), EOF_TOK))
        );
    }
}